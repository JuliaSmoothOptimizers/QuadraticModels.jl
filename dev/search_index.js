var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"​","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [QuadraticModels]","category":"page"},{"location":"reference/#QuadraticModels.QuadraticModel","page":"Reference","title":"QuadraticModels.QuadraticModel","text":"qp = QuadraticModel(c, Hrows, Hcols, Hvals; Arows = Arows, Acols = Acols, Avals = Avals, \n                    lcon = lcon, ucon = ucon, lvar = lvar, uvar = uvar, sortcols = false)\n\nqp = QuadraticModel(c, H; A = A, lcon = lcon, ucon = ucon, lvar = lvar, uvar = uvar)\n\nCreate a Quadratic model min tfrac12 x^T H x + c^T x + c_0 with optional bounds lvar ≦ x ≦ uvar and optional linear constraints lcon ≦ Ax ≦ ucon. The user should only give the lower triangle of H to the QuadraticModel constructor.\n\nWith the first constructor, if sortcols = true, then Hcols and Acols are sorted in ascending order  (Hrows, Hvals and Arows, Avals are then sorted accordingly).\n\nYou can also use QPSReader.jl to create a Quadratic model from a QPS file:\n\nusing QPSReader\nqps = readqps(\"QAFIRO.SIF\")\nqp = QuadraticModel(qps)\n\nThe instance of QuadraticModel{T, S, D} created contains the fields:\n\nmeta of type NLPModels.NLPModelMeta  from NLPModels.jl,\ndata, of type QuadraticModels.QPData depending on the input types of the A and H matrices.\ncounters of type NLPModels.Counters from NLPModels.jl.\n\nUsing NLPModelsModifiers.SlackModel from NLPModelsModifiers.jl with a QuadraticModel  based on a QPData with dense matrices will convert the field data to a QPData with SparseMatricesCOO.  \n\nIts in-place variant SlackModel! specific to QuadraticModels will only work with a QuadraticModel based on a QPData with SparseMatricesCOO.\n\n\n\n\n\n","category":"type"},{"location":"reference/#QuadraticModels.QuadraticModel-Union{Tuple{S}, Tuple{T}, Tuple{NLPModels.AbstractNLPModel{T, S}, AbstractVector}} where {T, S}","page":"Reference","title":"QuadraticModels.QuadraticModel","text":"QuadraticModel(nlp, x)\n\nCreates a quadratic Taylor model of nlp around x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#QuadraticModels.postsolve-Union{Tuple{S}, Tuple{T}, Tuple{QuadraticModel{T, S}, QuadraticModels.PresolvedQuadraticModel{T, S}, S, S, SparseArrays.SparseVector{T, Int64}, SparseArrays.SparseVector{T, Int64}}} where {T, S}","page":"Reference","title":"QuadraticModels.postsolve","text":"pt = postsolve(qm::QuadraticModel{T, S}, psqm::PresolvedQuadraticModel{T, S}, \n               x_in::S, y_in::S,\n               s_l_in::SparseVector{T, Int},\n               s_u_in::SparseVector{T, Int}) where {T, S}\n\nRetrieve the solution (x, y, s_l, s_u) of the original QP qm given the solution of the presolved QP (psqm) x_in, y_in, s_l_in, s_u_in.\n\n\n\n\n\n","category":"method"},{"location":"reference/#QuadraticModels.presolve-Union{Tuple{QuadraticModel{T, S, M1, M2}}, Tuple{M2}, Tuple{M1}, Tuple{S}, Tuple{T}} where {T<:Real, S, M1<:SparseMatricesCOO.SparseMatrixCOO, M2<:SparseMatricesCOO.SparseMatrixCOO}","page":"Reference","title":"QuadraticModels.presolve","text":"stats_ps = presolve(qm::QuadraticModel{T, S}; kwargs...)\n\nApply a presolve routine to qm and returns a  GenericExecutionStats from the package SolverCore.jl. The presolve operations currently implemented are:\n\nremove empty rows\nremove singleton rows\nfix linearly unconstrained variables (lps)\nremove free linear singleton columns whose associated variable does not appear in the hessian\nremove fixed variables\n\nThe PresolvedQuadraticModel{T, S} <: AbstractQuadraticModel{T, S} is located in the solver_specific field:\n\npsqm = stats_ps.solver_specific[:presolvedQM]\n\nand should be used to call postsolve.\n\nIf the presolved problem has 0 variables, stats_ps.solution contains a solution of the primal problem, stats_ps.multipliers is a zero SparseVector, and, if we define\n\ns = qm.data.c + qm.data.H * stats_ps.solution\n\nstats_ps.multipliers_L is the positive part of s and stats_ps.multipliers_U is the opposite of the negative part of s. The presolve operations are inspired from MathOptPresolve.jl, and from:\n\nGould, N., Toint, P. Preprocessing for quadratic programming, Math. Program., Ser. B 100, 95–132 (2004). \n\n\n\n\n\n","category":"method"},{"location":"#QuadraticModels.jl","page":"Home","title":"QuadraticModels.jl","text":"","category":"section"},{"location":"tutorial/#QuadraticModels.jl-Tutorial","page":"Tutorial","title":"QuadraticModels.jl Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can check an Introduction to QuadraticModels.jl on our site, jso-docs.","category":"page"}]
}
